#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

////定义一个数用来表示当前的位置为空，改数字只需要不在数据范围内就行
//const int N = 200000,null = 0x3f3f3f3f;
////开放寻址法只需要开一个数组就够了;
//int h[N];
//
//
////开放寻址法
///**********************开放寻址法**********************/
////插入
////如果x在哈希表中存在，返回x所在的位置;如果不存在就返回x应该在哈希表的位置
//int find(int x)
//{
//	int k = (x % N + N) % N;//这里的是为了保证k是一个正整数,获得x所在的哈希表的槽
//	while (h[k] != null && h[k] != x)
//	{
//		k++;
//		//k找到了最后一个数那么从头开始找
//		if (k = N) k = 0;
//	}
//	//返回的k要么是x正确的位置,要么x不存在哈希表中,k是x可以插入的位置
//	return k;
//}
//
//void insert(int x)
//{
//	int k = find(x);//k就是x应该插入的位置
//	h[k] = x;
//}
//
//
///**********************开放寻址法**********************/
//
//
//
//
//
//int main()
//{
//	//求一个大于200,000 的质数
//	for (int i = 200000; ; i++)
//	{
//		bool flag = true;
//		for (int j = 2; j * j <= i; j++)
//		{
//			if (i % j == 0)//如果i 能够整除j 说明i不是质数,直接跳出循环
//			{
//				flag = false;
//				break;
//			}
//		}
//
//		if (flag)
//		{
//			cout << i << endl;
//			//找到了第一个满足要求的质数就跳出循环
//			break;
//		}
//
//		//将h[N]中所有的槽的值清空,用null表示当前位置没有值;
//		memset(h, null, sizeof h);
//
//	}
//
//	return 0;
//}


/**********************笔记**********************/
/* 1. 哈希表
	a. 哈希表的存储结构(根据冲突的处理方式 划分)
		* 开放寻址法
		* 拉链法
	b. 字符串哈希方式

*/

//用scanf读入字符串,scanf会自动忽略空格,制表符一般不用scanf读字符串

/*如何理解 负数 mod N
C++ 中负数模上负数还是负数
正数摸上正数还是正数
*/

/**********************笔记**********************/