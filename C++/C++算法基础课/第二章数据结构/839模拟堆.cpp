#include <iostream>
#include <algorithm>

using namespace std;


//const int N = 100010;
//
//int n, m;
//int hsize, heap[N], heapp[N], pheap[N];
////开两个额外的数组记录第k个插入的数组; 
////pheap[N]:存第k个数插入堆的下标 heapp[N]: 堆里面的点是第几个插入的;
//
////两者互为反函数;每次交换堆里面的元素都要去维护这两个数组
//void heap_swap(int a, int b)
//{
//
//	swap(pheap[heapp[a]], pheap[heapp[b]]);
//	swap(heapp[a], heapp[b]);
//	swap(heap[a], heap[b]);
//}
//
//
//void down(int u)
//{
//	//用t表示三个节点的最小值;
//	int t = u;
//	//首先判断是否有左儿子,如果左儿子比父节点小,父节点与左儿子交换坐标;
//	if (u * 2 <= hsize && heap[u * 2] < heap[t]) t = u * 2;
//	//首先判断是否有右儿子,如果右儿子比父节点小,父节点与左儿子交换坐标;
//	if ((u * 2) + 1 <= hsize && heap[(u * 2) + 1] < heap[t]) t = (u * 2) + 1;
//	//如果当前节点不是二叉树的最后一层(第n层),那么递归,最后一层节点必然有u = t;
//	if (u != t)
//	{
//		//将当前坐标为u,t(三者的最小值)交换值
//		swap(heap[u], heap[t]);
//		down(t);
//	}
//}
//
//
//void up(int u)
//{
//	while (u / 2 && heap[u / 2] > heap[u])
//	{
//		swap(heap[u / 2], heap[u]);
//	}
//}
//
//int main()
//{
//	n = 5, m = 3;
//	heap[1] = 4;
//	heap[2] = 5;
//	heap[3] = 1;
//	heap[4] = 3;
//	heap[5] = 2;
//
//	hsize = 5;
//
//	//建立一个完全二叉树???
//	/**********************笔记**********************/
//	/*
//	从 i  = n / 2 开始down 有一下几个原因
//		a. 第n层的元素在down的时候始终会有u = t的情况
//		所以down的时候必须要有左右儿子
//		b. 同时要在下标最大的时候开始遍历,因为函数是i --从下往上迭代的
//	*/
//	/**********************笔记**********************/
//	for (int i = n / 2; i; i--)
//	{
//		down(i);
//	}
//
//	while (m--)
//	{
//		//先把当前最小的数输出出来
//		cout << heap[1];
//		//将原来最小的值用最大的值覆盖掉,相当于删除
//		heap[1] = heap[hsize];
//		//将原来的最大值down一下得到一个新的堆
//		down(1);
//	}
//
//	return 0;
//}


/**********************笔记**********************/
/*

如何手写一个堆？
1. 插入一个数
2. 求集合当中的最小值
3. 删除最小值
4. 删除任意一个元素
5。 修改任意一个元素

heap 堆； heapsize 堆的大小
* 向堆插入一个x的时候只需要在堆的最后一个位置插入
heap[ ++ heapsize] = x; up(size); up形参相当于元素
x的初始坐标
* 求当前堆的最小值 heap[1]
* 删除的基本原理就是把heap的最后一个值直接覆盖掉根节点,
之后 size -- ,最后down一下就好
heap[1] = heap[size]; size --; down(1);
*删除任意一个点方法同上
*heap[k] = heap[size]; size --; down(k); up(k);
删除的时候只有三种情况,只需要down一下up一下就能形成新的堆.
*只要修改一个节点那么down一下up一下就行
*下标从1开始,从0开始不太方便
* 求最小值的时候时间复杂度是O(1),插入与删除的时间复杂度是log(n)


*完全二叉树是logn层的
/**********************笔记**********************/